<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!-- åŸºæœ¬SEOæ¨™ç±¤ -->
    <title>å¥§ç‘ªå“ˆé«˜ä½ç‰Œå‹ç‡è¨ˆç®—å™¨ | Omaha Hi-Lo æ’²å…‹å‹ç‡åˆ†æå·¥å…·</title>
    <meta name="description" content="å°ˆæ¥­çš„å¥§ç‘ªå“ˆé«˜ä½ç‰Œ(Omaha Hi-Lo)å‹ç‡è¨ˆç®—å™¨ï¼Œæ”¯æ´æœ€å¤š9ä½ç©å®¶ï¼Œè’™ç‰¹å¡ç¾…æ¨¡æ“¬10000æ¬¡ï¼Œæä¾›ç²¾ç¢ºçš„å‹ç‡åˆ†æã€Scoopç‡ã€Splitç‡çµ±è¨ˆã€‚å…è²»ç·šä¸Šå·¥å…·ï¼Œæ‰‹æ©Ÿé›»è…¦éƒ½èƒ½ç”¨ã€‚">
    <meta name="keywords" content="å¥§ç‘ªå“ˆé«˜ä½ç‰Œ,Omaha Hi-Lo,æ’²å…‹å‹ç‡è¨ˆç®—å™¨,å¾·å·æ’²å…‹,å‹ç‡åˆ†æ,è’™ç‰¹å¡ç¾…æ¨¡æ“¬,æ’²å…‹å·¥å…·,ç·šä¸Šè¨ˆç®—å™¨,poker calculator">
    <meta name="author" content="Leon Cypher">
    <meta name="robots" content="index, follow">
    <meta name="language" content="zh-TW">
    
    <!-- Open Graphæ¨™ç±¤(Facebookåˆ†äº«) -->
    <meta property="og:title" content="å¥§ç‘ªå“ˆé«˜ä½ç‰Œå‹ç‡è¨ˆç®—å™¨ | å°ˆæ¥­æ’²å…‹åˆ†æå·¥å…·">
    <meta property="og:description" content="å…è²»çš„å¥§ç‘ªå“ˆé«˜ä½ç‰Œå‹ç‡è¨ˆç®—å™¨ï¼Œæ”¯æ´å¤šç©å®¶åˆ†æï¼Œè’™ç‰¹å¡ç¾…10000æ¬¡æ¨¡æ“¬ï¼Œæä¾›ç²¾ç¢ºçµ±è¨ˆæ•¸æ“š">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://leon-cypher.github.io/omaha_hilo_calculator/">
    <meta property="og:site_name" content="å¥§ç‘ªå“ˆé«˜ä½ç‰Œå‹ç‡è¨ˆç®—å™¨">
    <meta property="og:locale" content="zh_TW">
    
    <!-- Twitter Cardæ¨™ç±¤ -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="å¥§ç‘ªå“ˆé«˜ä½ç‰Œå‹ç‡è¨ˆç®—å™¨">
    <meta name="twitter:description" content="å°ˆæ¥­çš„Omaha Hi-Loæ’²å…‹å‹ç‡åˆ†æå·¥å…·ï¼Œå…è²»ç·šä¸Šä½¿ç”¨">
    
    <!-- æŠ€è¡“æ¨™ç±¤ -->
    <meta name="theme-color" content="#000000">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="å¥§ç‘ªå“ˆè¨ˆç®—å™¨">
    
    <!-- çµæ§‹åŒ–æ•¸æ“š -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "WebApplication",
        "name": "å¥§ç‘ªå“ˆé«˜ä½ç‰Œå‹ç‡è¨ˆç®—å™¨",
        "description": "å°ˆæ¥­çš„å¥§ç‘ªå“ˆé«˜ä½ç‰Œ(Omaha Hi-Lo)å‹ç‡è¨ˆç®—å™¨ï¼Œæ”¯æ´æœ€å¤š9ä½ç©å®¶ï¼Œè’™ç‰¹å¡ç¾…æ¨¡æ“¬åˆ†æ",
        "url": "https://leon-cypher.github.io/omaha_hilo_calculator/",
        "applicationCategory": "GameApplication",
        "operatingSystem": "Any",
        "permissions": "browser",
        "offers": {
            "@type": "Offer",
            "price": "0",
            "priceCurrency": "USD"
        },
        "author": {
            "@type": "Person",
            "name": "Leon Cypher"
        }
    }
    </script>
    
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft JhengHei', 'PingFang TC', 'Hiragino Sans TC', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #000000;
            color: white;
            min-height: 100vh;
        }

        #app {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .app-header {
            text-align: center;
            padding: 2rem 1rem;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .app-header h1 {
            font-size: 2rem;
            margin-bottom: 0.5rem;
            font-weight: 700;
        }

        .app-main {
            flex: 1;
            max-width: 1200px;
            margin: 0 auto;
            padding: 1rem;
            width: 100%;
        }

        .content-wrapper {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .left-panel {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .right-panel {
            display: none; /* éš±è—åŸä¾†çš„ç‰Œå † */
        }

        /* å½ˆå‡ºå¼ç‰Œé¸æ“‡å™¨ */
        .card-selector-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 1rem;
        }

        .card-selector-content {
            background: #111;
            border-radius: 15px;
            padding: 1.5rem;
            max-width: 90vw;
            width: 100%;
            max-height: 85vh;
            overflow-y: auto;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        .selector-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }

        .selector-title {
            font-size: 1.2rem;
            font-weight: bold;
        }

        .close-btn {
            background: rgba(255, 0, 0, 0.6);
            color: white;
            border: none;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 1.2rem;
        }

        .close-btn:hover {
            background: rgba(255, 0, 0, 0.8);
        }

        /* æ©«å‘èŠ±è‰²å±•ç¤º */
        .suits-container {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .suit-row {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: rgba(255, 255, 255, 0.02);
            padding: 1rem;
            border-radius: 8px;
        }

        .suit-label {
            min-width: 50px;
            text-align: center;
            font-size: 2.2rem;
            font-weight: 900;
            margin-right: 0.75rem;
        }

        .suit-label.red { color: #ff4757; }
        .suit-label.black { color: #ecf0f1; }

        .cards-row {
            display: flex;
            gap: 0.25rem;
            flex-wrap: wrap;
            flex: 1;
        }

        .card-button {
            min-width: 50px;
            height: 70px;
            border-radius: 8px;
            border: 2px solid #ddd;
            background: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.1rem;
            font-weight: 900;
            cursor: pointer;
            transition: all 0.2s ease;
            user-select: none;
            flex-shrink: 0;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .card-button:hover {
            transform: scale(1.08);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
            border-color: #999;
        }

        .card-button.selected {
            background: #00ff00;
            border-color: #00cc00;
            transform: scale(1.02);
        }

        .card-button.used {
            background: #666;
            color: #999;
            border-color: #555;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .card-button.used:hover {
            transform: none;
            box-shadow: none;
        }

        .card-button.spades { color: #2c3e50; } /* é»‘æ¡ƒ - é»‘è‰² */
        .card-button.hearts { color: #e74c3c; } /* æ„›å¿ƒ - ç´…è‰² */
        .card-button.diamonds { color: #3498db; } /* æ–¹å¡Š - æ·ºè—è‰² */
        .card-button.clubs { color: #27ae60; } /* æ¢…èŠ± - ç¶ è‰² */

        .selection-info {
            text-align: center;
            margin-bottom: 1rem;
            padding: 0.75rem;
            background: rgba(0, 210, 255, 0.1);
            border-radius: 8px;
            border: 1px solid rgba(0, 210, 255, 0.3);
        }

        .selection-count {
            font-weight: bold;
            color: #00d2ff;
        }

        .card {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 15px;
            padding: 1.5rem;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .card h3 {
            margin-bottom: 1rem;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .input-group {
            margin: 0.75rem 0;
        }

        .input-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 600;
            font-size: 0.9rem;
        }

        .text-input, .select-input {
            width: 100%;
            padding: 0.75rem;
            border: none;
            border-radius: 8px;
            font-size: 0.9rem;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            transition: all 0.3s ease;
        }

        .text-input:focus, .select-input:focus {
            outline: none;
            background: rgba(255, 255, 255, 1);
            box-shadow: 0 0 0 2px rgba(103, 126, 234, 0.3);
        }

        .players-container {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .player-row {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            background: rgba(255, 255, 255, 0.05);
            padding: 0.75rem;
            border-radius: 8px;
            transition: all 0.3s ease;
        }

        .player-row.active {
            background: rgba(255, 215, 0, 0.15);
            border: 1px solid rgba(255, 215, 0, 0.4);
        }

        .player-label {
            min-width: 70px;
            padding: 0.4rem 0.8rem;
            border-radius: 6px;
            font-weight: 600;
            font-size: 0.85rem;
            text-align: center;
            color: white;
            flex-shrink: 0;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }

        .player-label:hover {
            transform: scale(1.05);
        }

        .player-label::after {
            content: ' ğŸ‘†';
            font-size: 0.7rem;
            opacity: 0.8;
        }

        .player-cards {
            flex: 1;
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .selected-cards {
            display: flex;
            gap: 0.25rem;
            flex: 1;
        }

        .clear-btn {
            background: rgba(255, 0, 0, 0.6);
            color: white;
            border: none;
            border-radius: 4px;
            padding: 0.25rem 0.5rem;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .clear-btn:hover {
            background: rgba(255, 0, 0, 0.8);
        }

        /* æ’²å…‹ç‰Œå †å€åŸŸ */
        .deck-area {
            background: rgba(255, 255, 255, 0.03);
            border-radius: 12px;
            padding: 1rem;
            max-height: 600px;
            overflow-y: auto;
        }

        .deck-title {
            text-align: center;
            margin-bottom: 1rem;
            font-weight: 600;
        }

        .deck-instructions {
            text-align: center;
            font-size: 0.8rem;
            opacity: 0.8;
            margin-bottom: 1rem;
        }

        .suits-container {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .suit-row {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .suit-label {
            width: 30px;
            text-align: center;
            font-size: 1.2rem;
            font-weight: bold;
            margin-right: 0.5rem;
        }

        .suit-label.spades { color: #2c3e50; } /* é»‘æ¡ƒ - é»‘è‰² */
        .suit-label.hearts { color: #e74c3c; } /* æ„›å¿ƒ - ç´…è‰² */
        .suit-label.diamonds { color: #3498db; } /* æ–¹å¡Š - æ·ºè—è‰² */
        .suit-label.clubs { color: #27ae60; } /* æ¢…èŠ± - ç¶ è‰² */

        .cards-row {
            display: flex;
            gap: 0.25rem;
            flex-wrap: wrap;
        }

        /* æ’²å…‹ç‰Œæ¨£å¼ */
        .playing-card {
            width: 32px;
            height: 44px;
            border-radius: 4px;
            border: 1px solid #ddd;
            background: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            user-select: none;
        }

        .playing-card:hover {
            transform: scale(1.1);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .playing-card.selected {
            background: #ffd700;
            transform: scale(1.05);
            box-shadow: 0 2px 8px rgba(255, 215, 0, 0.5);
        }

        .playing-card.used {
            background: #ccc;
            opacity: 0.5;
            cursor: not-allowed;
        }

        .playing-card.spades { color: #2c3e50; } /* é»‘æ¡ƒ - é»‘è‰² */
        .playing-card.hearts { color: #e74c3c; } /* æ„›å¿ƒ - ç´…è‰² */
        .playing-card.diamonds { color: #3498db; } /* æ–¹å¡Š - æ·ºè—è‰² */
        .playing-card.clubs { color: #27ae60; } /* æ¢…èŠ± - ç¶ è‰² */

        .mini-card {
            width: 32px;
            height: 44px;
            border-radius: 4px;
            border: 1px solid #ddd;
            background: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.85rem;
            font-weight: 800;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .mini-card.spades { color: #2c3e50; } /* é»‘æ¡ƒ - é»‘è‰² */
        .mini-card.hearts { color: #e74c3c; } /* æ„›å¿ƒ - ç´…è‰² */
        .mini-card.diamonds { color: #3498db; } /* æ–¹å¡Š - æ·ºè—è‰² */
        .mini-card.clubs { color: #27ae60; } /* æ¢…èŠ± - ç¶ è‰² */

        .button-group {
            display: flex;
            gap: 0.75rem;
            flex-wrap: wrap;
        }

        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            flex: 1;
            min-width: 120px;
        }

        .btn-primary {
            background: linear-gradient(45deg, #ff4757, #ff6348);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(255, 71, 87, 0.4);
        }

        .btn-primary:disabled {
            opacity: 0.7;
            cursor: not-allowed;
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .loading {
            text-align: center;
            padding: 1.5rem;
        }

        .spinner {
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top: 3px solid white;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto 1rem;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error {
            background: rgba(244, 67, 54, 0.2);
            border: 1px solid rgba(244, 67, 54, 0.5);
            color: #ffcdd2;
            padding: 1rem;
            border-radius: 8px;
            margin: 1rem 0;
            text-align: center;
        }

        .results-section {
            grid-column: 1 / -1;
        }

        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 1rem;
        }

        .result-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 1rem;
            border-left: 4px solid #00d2ff;
        }

        .result-header {
            margin-bottom: 0.75rem;
            text-align: center;
        }

        .player-name {
            display: block;
            font-size: 1rem;
            font-weight: 700;
            margin-bottom: 0.25rem;
        }

        .player-hand {
            display: block;
            font-size: 0.8rem;
            opacity: 0.8;
            font-family: 'Courier New', monospace;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 0.25rem 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 0.9rem;
        }

        .stat-row:last-child {
            border-bottom: none;
        }

        .stat-row.main-stat {
            background: rgba(255, 255, 255, 0.1);
            padding: 0.5rem;
            border-radius: 5px;
            margin-bottom: 0.5rem;
            border-bottom: none;
        }

        .stat-value.primary {
            font-size: 1.1rem;
            color: #00d2ff;
        }

        .help-text {
            font-size: 0.8rem;
            opacity: 0.8;
            margin-top: 0.5rem;
        }

        /* éŸ¿æ‡‰å¼è¨­è¨ˆ */
        @media (max-width: 1024px) {
            .app-main {
                grid-template-columns: 1fr;
                max-width: 800px;
            }
            
            .deck-area {
                max-height: 400px;
            }
            
            .cards-row {
                justify-content: center;
            }
        }

        @media (max-width: 768px) {
            .app-header h1 {
                font-size: 1.5rem;
            }
            
            .card {
                padding: 1rem;
            }
            
            .player-row {
                flex-direction: column;
                align-items: stretch;
                gap: 0.75rem;
            }
            
            .player-label {
                min-width: auto;
                text-align: center;
            }
            
            .button-group {
                flex-direction: column;
            }
            
            .btn {
                min-width: auto;
            }
            
            .results-grid {
                grid-template-columns: 1fr;
            }

            .card-selector-content {
                max-width: 95vw;
                padding: 1rem;
            }

            .suit-row {
                flex-direction: column;
                align-items: stretch;
                gap: 0.5rem;
            }

            .suit-label {
                text-align: center;
                margin-right: 0;
                margin-bottom: 0.5rem;
                font-size: 2rem;
            }

            .cards-row {
                justify-content: center;
            }

            .card-button {
                min-width: 42px;
                height: 60px;
                font-size: 0.95rem;
                font-weight: 800;
            }

            .mini-card {
                width: 28px;
                height: 38px;
                font-size: 0.75rem;
            }
        }

        @media (max-width: 480px) {
            .app-header {
                padding: 1.5rem 1rem;
            }
            
            .app-header h1 {
                font-size: 1.3rem;
            }
            
            .card {
                padding: 1rem;
                margin: 1rem 0;
            }

            .card-selector-content {
                padding: 1rem;
            }

            .card-button {
                min-width: 38px;
                height: 54px;
                font-size: 0.85rem;
                font-weight: 800;
            }

            .suit-label {
                font-size: 1.8rem;
            }

            .mini-card {
                width: 26px;
                height: 36px;
                font-size: 0.7rem;
            }
        }
    </style>
</head>
<body>
    <div id="app">
        <header class="app-header">
            <h1>ğŸ¯ 5å¼µå¥§ç‘ªå“ˆé«˜ä½ç‰Œå‹ç‡è¨ˆç®—å™¨</h1>
            <p>é»æ“Šæ’²å…‹ç‰Œé¸æ“‡ | è’™ç‰¹å¡ç¾…æ¨¡æ“¬ | Vueç‰ˆ</p>
        </header>

        <main class="app-main">
            <div class="content-wrapper">
                <!-- ç©å®¶æ‰‹ç‰Œè¨­å®š -->
                <section class="card">
                    <h3>ğŸ´ ç©å®¶æ‰‹ç‰Œ</h3>
                    
                    <div class="input-group">
                        <label>ç©å®¶æ•¸é‡</label>
                        <select v-model="playerCount" class="select-input">
                            <option v-for="n in 8" :key="n+1" :value="n+1">{{ n+1 }}äºº</option>
                        </select>
                    </div>

                    <div class="players-container">
                        <div 
                            v-for="(player, index) in currentPlayers" 
                            :key="index"
                            class="player-row"
                        >
                            <div 
                                class="player-label" 
                                :style="{ backgroundColor: player.color }"
                                @click="openCardSelector(index)"
                            >
                                ç©å®¶{{ index + 1 }}
                            </div>
                            <div class="player-cards">
                                <div class="selected-cards">
                                    <div 
                                        v-for="card in playerHands[index]" 
                                        :key="card"
                                        class="mini-card"
                                        :class="getCardColor(card)"
                                    >
                                        {{ card }}
                                    </div>
                                </div>
                                <button 
                                    v-if="playerHands[index].length > 0"
                                    @click="clearPlayerCards(index)"
                                    class="clear-btn"
                                >
                                    æ¸…é™¤
                                </button>
                            </div>
                        </div>
                    </div>

                    <div class="help-text">
                        é»æ“Šç©å®¶æ¨™ç±¤é–‹å•Ÿç‰Œé¸æ“‡å™¨ï¼Œæ¯å€‹ç©å®¶éœ€è¦é¸æ“‡5å¼µç‰Œ
                    </div>
                </section>

                <!-- å…¬å…±ç‰Œè¨­å®š -->
                <section class="card">
                    <h3>ğŸƒ å…¬å…±ç‰Œ</h3>
                    <div 
                        class="player-row"
                    >
                        <div 
                            class="player-label" 
                            style="background-color: #27ae60"
                            @click="openCardSelector('board')"
                        >
                            å…¬å…±ç‰Œ
                        </div>
                        <div class="player-cards">
                            <div class="selected-cards">
                                <div 
                                    v-for="card in boardCards" 
                                    :key="card"
                                    class="mini-card"
                                    :class="getCardColor(card)"
                                >
                                    {{ card }}
                                </div>
                            </div>
                            <button 
                                v-if="boardCards.length > 0"
                                @click="clearBoardCards()"
                                class="clear-btn"
                            >
                                æ¸…é™¤
                            </button>
                        </div>
                    </div>
                    <div class="help-text">
                        ç¿»ç‰Œå‰å¯ç•™ç©ºï¼Œç¿»ç‰Œå¾Œé¸æ“‡å·²çŸ¥å…¬å…±ç‰Œï¼ˆæœ€å¤š5å¼µï¼‰
                    </div>
                </section>

                <!-- è¨ˆç®—è¨­å®šå’ŒæŒ‰éˆ• -->
                <section class="card">
                    <h3>ğŸ² é–‹å§‹è¨ˆç®—</h3>

                    <div class="button-group">
                        <button @click="clearAll" class="btn btn-secondary">
                            ğŸ—‘ï¸ æ¸…é™¤å…¨éƒ¨
                        </button>
                        <button 
                            @click="calculateEquity" 
                            :disabled="isCalculating || !canCalculate"
                            class="btn btn-primary"
                        >
                            <span v-if="isCalculating">â³ è¨ˆç®—ä¸­...</span>
                            <span v-else>ğŸ² è¨ˆç®—å‹ç‡ (10,000æ¬¡)</span>
                        </button>
                    </div>
                </section>

                <!-- è¼‰å…¥å’ŒéŒ¯èª¤ -->
                <div v-if="isCalculating" class="loading">
                    <div class="spinner"></div>
                    <p>æ­£åœ¨é€²è¡Œ 10,000 æ¬¡è’™ç‰¹å¡ç¾…æ¨¡æ“¬...</p>
                </div>

                <div v-if="error" class="error">
                    {{ error }}
                </div>

                <!-- çµæœé¡¯ç¤º -->
                <section v-if="results" class="card results-section">
                    <h3>ğŸ“Š å‹ç‡çµæœ</h3>
                    <p style="text-align: center; margin-bottom: 1rem; opacity: 0.9;">
                        æ¨¡æ“¬æ¬¡æ•¸: <strong>10,000</strong> æ¬¡
                    </p>

                    <div class="results-grid">
                        <div 
                            v-for="player in results.players" 
                            :key="player.player"
                            class="result-card"
                            :style="{ borderLeftColor: player.color }"
                        >
                            <div class="result-header">
                                <span class="player-name">{{ player.player }}</span>
                                <span class="player-hand">{{ player.hand }}</span>
                            </div>
                            
                            <div class="stat-row main-stat">
                                <span>ç¸½å‹ç‡ (Equity)</span>
                                <span class="stat-value primary">{{ player.equity.toFixed(2) }}%</span>
                            </div>
                            <div class="stat-row">
                                <span>é«˜ç‰Œç²å‹ç‡</span>
                                <span class="stat-value">{{ player.hi_win_rate.toFixed(2) }}%</span>
                            </div>
                            <div class="stat-row">
                                <span>ä½ç‰Œç²å‹ç‡</span>
                                <span class="stat-value">{{ player.lo_win_rate.toFixed(2) }}%</span>
                            </div>
                            <div class="stat-row">
                                <span>Scoopç‡ (æ•´å€‹åº•æ± )</span>
                                <span class="stat-value">{{ player.scoop_rate.toFixed(2) }}%</span>
                            </div>
                            <div class="stat-row">
                                <span>ç²å¾—3/4åº•æ± </span>
                                <span class="stat-value">{{ player.three_quarter_rate.toFixed(2) }}%</span>
                            </div>
                            <div class="stat-row">
                                <span>Splitç‡ (1/2åº•æ± )</span>
                                <span class="stat-value">{{ player.split_rate.toFixed(2) }}%</span>
                            </div>
                            <div class="stat-row">
                                <span>ç²å¾—1/4åº•æ± </span>
                                <span class="stat-value">{{ player.quarter_rate.toFixed(2) }}%</span>
                            </div>
                        </div>
                    </div>
                </section>
            </div>

            <!-- å½ˆå‡ºå¼ç‰Œé¸æ“‡å™¨ -->
            <div v-if="showCardSelector" class="card-selector-modal" @click="closeCardSelector">
                <div class="card-selector-content" @click.stop>
                    <div class="selector-header">
                        <div class="selector-title">
                            {{ selectorTarget === 'board' ? 'é¸æ“‡å…¬å…±ç‰Œ' : `é¸æ“‡ç©å®¶${selectorTarget + 1}çš„æ‰‹ç‰Œ` }}
                        </div>
                        <button class="close-btn" @click="closeCardSelector">Ã—</button>
                    </div>

                    <!-- é¸æ“‡ç‹€æ…‹ -->
                    <div class="selection-info">
                        <span class="selection-count">
                            {{ selectorTarget === 'board' ? 
                                `å·²é¸æ“‡ ${boardCards.length}/5 å¼µå…¬å…±ç‰Œ` : 
                                `å·²é¸æ“‡ ${playerHands[selectorTarget]?.length || 0}/5 å¼µæ‰‹ç‰Œ` 
                            }}
                        </span>
                        <div style="font-size: 0.8rem; margin-top: 0.25rem; opacity: 0.8;">
                            é»æ“Šæ’²å…‹ç‰Œé¸æ“‡ï¼Œå†æ¬¡é»æ“Šå¯å–æ¶ˆé¸æ“‡
                        </div>
                    </div>

                    <!-- æ©«å‘èŠ±è‰²å±•ç¤º -->
                    <div class="suits-container">
                        <div v-for="suit in suits" :key="suit.symbol" class="suit-row">
                            <div class="suit-label" :class="suit.color">{{ suit.symbol }}</div>
                            <div class="cards-row">
                                <div 
                                    v-for="rank in ranks" 
                                    :key="rank + suit.symbol"
                                    class="card-button"
                                    :class="[
                                        suit.color,
                                        { 
                                            selected: isCardSelected(rank + suit.letter),
                                            used: isCardUsedByOthers(rank + suit.letter)
                                        }
                                    ]"
                                    @click="toggleCard(rank + suit.letter)"
                                >
                                    {{ rank }}
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script>
        const { createApp, ref, computed } = Vue

        createApp({
            setup() {
                // éŸ¿æ‡‰å¼æ•¸æ“š
                const playerCount = ref(2)
                const playerHands = ref(Array(9).fill().map(() => []))
                const boardCards = ref([])
                const isCalculating = ref(false)
                const results = ref(null)
                const error = ref('')
                const selectedCards = ref([])
                
                // å½ˆå‡ºå¼é¸æ“‡å™¨ç›¸é—œ
                const showCardSelector = ref(false)
                const selectorTarget = ref(null) // 'board' æˆ–ç©å®¶ç´¢å¼•

                const playerColors = [
                    '#3498db', '#e74c3c', '#f39c12', '#9b59b6', 
                    '#1abc9c', '#e67e22', '#34495e', '#16a085', '#8e44ad'
                ]

                const suits = [
                    { symbol: 'â™ ', letter: 's', color: 'spades' },
                    { symbol: 'â™¥', letter: 'h', color: 'hearts' },
                    { symbol: 'â™¦', letter: 'd', color: 'diamonds' },
                    { symbol: 'â™£', letter: 'c', color: 'clubs' }
                ]

                const ranks = ['A', 'K', 'Q', 'J', 'T', '9', '8', '7', '6', '5', '4', '3', '2']

                // è¨ˆç®—å±¬æ€§
                const currentPlayers = computed(() => {
                    return Array.from({ length: playerCount.value }, (_, i) => ({
                        id: i + 1,
                        color: playerColors[i % playerColors.length]
                    }))
                })

                const canCalculate = computed(() => {
                    return playerHands.value.slice(0, playerCount.value).every(hand => hand.length === 5)
                })

                // æ–¹æ³•
                function openCardSelector(target) {
                    selectorTarget.value = target
                    showCardSelector.value = true
                    selectedCards.value = []
                }

                function closeCardSelector() {
                    showCardSelector.value = false
                    selectorTarget.value = null
                    selectedCards.value = []
                }

                function toggleCard(card) {
                    // æª¢æŸ¥æ˜¯å¦è¢«å…¶ä»–ç©å®¶æˆ–å…¬å…±ç‰Œä½¿ç”¨
                    if (isCardUsedByOthers(card)) return

                    if (selectorTarget.value === 'board') {
                        const index = boardCards.value.indexOf(card)
                        if (index > -1) {
                            // å–æ¶ˆé¸æ“‡
                            boardCards.value.splice(index, 1)
                        } else if (boardCards.value.length < 5) {
                            // é¸æ“‡
                            boardCards.value.push(card)
                        }
                    } else {
                        const playerIndex = selectorTarget.value
                        const index = playerHands.value[playerIndex].indexOf(card)
                        if (index > -1) {
                            // å–æ¶ˆé¸æ“‡
                            playerHands.value[playerIndex].splice(index, 1)
                        } else if (playerHands.value[playerIndex].length < 5) {
                            // é¸æ“‡
                            playerHands.value[playerIndex].push(card)
                        }
                    }
                }

                function isCardSelected(card) {
                    if (selectorTarget.value === 'board') {
                        return boardCards.value.includes(card)
                    } else {
                        return playerHands.value[selectorTarget.value]?.includes(card) || false
                    }
                }

                function isCardUsedByOthers(card) {
                    // æª¢æŸ¥æ˜¯å¦è¢«å…¶ä»–ç©å®¶æˆ–å…¬å…±ç‰Œä½¿ç”¨ï¼ˆä¸åŒ…æ‹¬ç•¶å‰é¸æ“‡å™¨çš„ç›®æ¨™ï¼‰
                    if (selectorTarget.value !== 'board' && boardCards.value.includes(card)) {
                        return true
                    }
                    
                    for (let i = 0; i < playerHands.value.length; i++) {
                        if (i !== selectorTarget.value && playerHands.value[i].includes(card)) {
                            return true
                        }
                    }
                    
                    return false
                }

                function isCardUsed(card) {
                    // æª¢æŸ¥æ˜¯å¦å·²è¢«ä»»ä½•ç©å®¶æˆ–å…¬å…±ç‰Œä½¿ç”¨
                    for (let hand of playerHands.value) {
                        if (hand.includes(card)) return true
                    }
                    return boardCards.value.includes(card)
                }

                function getCardColor(card) {
                    const suit = card.slice(-1)
                    const suitMap = {
                        's': 'spades',   // é»‘æ¡ƒ
                        'h': 'hearts',   // æ„›å¿ƒ
                        'd': 'diamonds', // æ–¹å¡Š
                        'c': 'clubs'     // æ¢…èŠ±
                    }
                    return suitMap[suit] || 'spades'
                }

                function clearPlayerCards(index) {
                    playerHands.value[index] = []
                }

                function clearBoardCards() {
                    boardCards.value = []
                }

                function clearAll() {
                    playerHands.value = Array(9).fill().map(() => [])
                    boardCards.value = []
                    results.value = null
                    error.value = ''
                    selectedCards.value = []
                    closeCardSelector()
                }

                // éŠæˆ²é‚è¼¯ï¼ˆç°¡åŒ–ç‰ˆï¼Œèˆ‡ä¹‹å‰ç›¸åŒï¼‰
                class Card {
                    constructor(rank, suit) {
                        this.rank = rank
                        this.suit = suit
                        this.value = Card.getRankValue(rank)
                    }

                    static getRankValue(rank) {
                        const values = {
                            '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9,
                            'T': 10, 'J': 11, 'Q': 12, 'K': 13, 'A': 14
                        }
                        return values[rank] || 0
                    }

                    toString() {
                        return this.rank + this.suit
                    }
                }

                function parseCards(cardArray) {
                    return cardArray.map(cardStr => {
                        const rank = cardStr[0]
                        const suitLetter = cardStr[1]
                        const suitSymbols = { 's': 'â™ ', 'h': 'â™¥', 'd': 'â™¦', 'c': 'â™£' }
                        return new Card(rank, suitSymbols[suitLetter])
                    })
                }

                // é€™è£¡åŒ…å«ä¹‹å‰çš„è¨ˆç®—é‚è¼¯...
                class HandEvaluator {
                    static evaluateHiHand(cards) {
                        if (cards.length !== 5) return 0
                        
                        const ranks = cards.map(c => c.value).sort((a, b) => b - a)
                        const suits = cards.map(c => c.suit)
                        const rankCounts = {}
                        
                        ranks.forEach(rank => {
                            rankCounts[rank] = (rankCounts[rank] || 0) + 1
                        })
                        
                        const counts = Object.values(rankCounts).sort((a, b) => b - a)
                        const isFlush = new Set(suits).size === 1
                        const isStraight = this.isStraight(ranks)
                        
                        if (isFlush && isStraight) return 8000000 + ranks[0]
                        if (counts[0] === 4) return 7000000 + ranks[0] * 1000
                        if (counts[0] === 3 && counts[1] === 2) return 6000000 + ranks[0] * 1000
                        if (isFlush) return 5000000 + ranks[0]
                        if (isStraight) return 4000000 + ranks[0]
                        if (counts[0] === 3) return 3000000 + ranks[0] * 1000
                        if (counts[0] === 2 && counts[1] === 2) return 2000000 + ranks[0] * 1000
                        if (counts[0] === 2) return 1000000 + ranks[0] * 1000
                        
                        return ranks[0] * 10000 + ranks[1] * 100 + ranks[2]
                    }
                    
                    static isStraight(sortedRanks) {
                        let isStandardStraight = true
                        for (let i = 0; i < 4; i++) {
                            if (sortedRanks[i] - sortedRanks[i + 1] !== 1) {
                                isStandardStraight = false
                                break
                            }
                        }
                        
                        if (isStandardStraight) return true
                        
                        if (sortedRanks[0] === 14 && sortedRanks[1] === 5 && sortedRanks[2] === 4 && 
                            sortedRanks[3] === 3 && sortedRanks[4] === 2) {
                            return true
                        }
                        
                        return false
                    }
                    
                    static evaluateLoHand(cards) {
                        if (cards.length !== 5) return null
                        
                        const ranks = cards.map(c => c.value === 14 ? 1 : c.value)
                        
                        if (ranks.some(r => r > 8)) return null
                        if (new Set(ranks).size !== 5) return null
                        
                        return parseInt(ranks.sort((a, b) => b - a).join(''))
                    }
                }

                class EquityCalculator {
                    static calculateEquity(playersHands, boardCards = [], simulations = 5000) {
                        const deck = this.createDeck()
                        const usedCards = new Set()
                        
                        playersHands.forEach(hand => {
                            hand.forEach(card => usedCards.add(card.toString()))
                        })
                        boardCards.forEach(card => usedCards.add(card.toString()))
                        
                        const availableCards = deck.filter(card => !usedCards.has(card.toString()))
                        
                        const results = {}
                        playersHands.forEach((_, i) => {
                            results[`player_${i}`] = {
                                equity: 0,
                                hi_wins: 0,
                                lo_wins: 0,
                                scoops: 0,        // ç²å¾—æ•´å€‹åº•æ± 
                                splits: 0,       // å¹³åˆ†åº•æ±  (1/2)
                                quarters: 0,     // ç²å¾—1/4åº•æ± 
                                three_quarters: 0 // ç²å¾—3/4åº•æ± 
                            }
                        })
                        
                        for (let sim = 0; sim < simulations; sim++) {
                            const shuffled = this.shuffle([...availableCards])
                            const finalBoard = [...boardCards]
                            
                            let cardIndex = 0
                            while (finalBoard.length < 5) {
                                finalBoard.push(shuffled[cardIndex++])
                            }
                            
                            const playerResults = []
                            
                            for (let i = 0; i < playersHands.length; i++) {
                                const bestHi = this.getBestHiHand(playersHands[i], finalBoard)
                                const bestLo = this.getBestLoHand(playersHands[i], finalBoard)
                                
                                playerResults.push({
                                    player: i,
                                    hiStrength: bestHi,
                                    loStrength: bestLo
                                })
                            }
                            
                            this.determineWinners(playerResults, results)
                        }
                        
                        Object.keys(results).forEach(player => {
                            const stats = results[player]
                            stats.hi_win_rate = (stats.hi_wins / simulations) * 100
                            stats.lo_win_rate = (stats.lo_wins / simulations) * 100
                            stats.scoop_rate = (stats.scoops / simulations) * 100
                            stats.split_rate = (stats.splits / simulations) * 100
                            stats.quarter_rate = (stats.quarters / simulations) * 100
                            stats.three_quarter_rate = (stats.three_quarters / simulations) * 100
                            // ä¿®æ­£ç¸½å‹ç‡è¨ˆç®—ï¼šåŠ æ¬Šè¨ˆç®—ç²å¾—åº•æ± çš„æœŸæœ›å€¼
                            stats.equity = ((stats.scoops * 1.0 + stats.three_quarters * 0.75 + stats.splits * 0.5 + stats.quarters * 0.25) / simulations) * 100
                        })
                        
                        return results
                    }
                    
                    static createDeck() {
                        const suits = ['â™ ', 'â™¥', 'â™¦', 'â™£']
                        const ranks = ['2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A']
                        const deck = []
                        
                        for (const suit of suits) {
                            for (const rank of ranks) {
                                deck.push(new Card(rank, suit))
                            }
                        }
                        
                        return deck
                    }
                    
                    static shuffle(array) {
                        for (let i = array.length - 1; i > 0; i--) {
                            const j = Math.floor(Math.random() * (i + 1));
                            [array[i], array[j]] = [array[j], array[i]]
                        }
                        return array
                    }
                    
                    static getBestHiHand(holeCards, boardCards) {
                        let bestStrength = 0
                        
                        for (let h1 = 0; h1 < holeCards.length; h1++) {
                            for (let h2 = h1 + 1; h2 < holeCards.length; h2++) {
                                for (let b1 = 0; b1 < boardCards.length; b1++) {
                                    for (let b2 = b1 + 1; b2 < boardCards.length; b2++) {
                                        for (let b3 = b2 + 1; b3 < boardCards.length; b3++) {
                                            const hand = [
                                                holeCards[h1], holeCards[h2],
                                                boardCards[b1], boardCards[b2], boardCards[b3]
                                            ]
                                            
                                            const strength = HandEvaluator.evaluateHiHand(hand)
                                            if (strength > bestStrength) {
                                                bestStrength = strength
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        
                        return bestStrength
                    }
                    
                    static getBestLoHand(holeCards, boardCards) {
                        let bestStrength = null
                        
                        for (let h1 = 0; h1 < holeCards.length; h1++) {
                            for (let h2 = h1 + 1; h2 < holeCards.length; h2++) {
                                for (let b1 = 0; b1 < boardCards.length; b1++) {
                                    for (let b2 = b1 + 1; b2 < boardCards.length; b2++) {
                                        for (let b3 = b2 + 1; b3 < boardCards.length; b3++) {
                                            const hand = [
                                                holeCards[h1], holeCards[h2],
                                                boardCards[b1], boardCards[b2], boardCards[b3]
                                            ]
                                            
                                            const strength = HandEvaluator.evaluateLoHand(hand)
                                            if (strength !== null) {
                                                if (bestStrength === null || strength < bestStrength) {
                                                    bestStrength = strength
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        
                        return bestStrength
                    }
                    
                    static determineWinners(playerResults, results) {
                        const maxHi = Math.max(...playerResults.map(p => p.hiStrength))
                        const hiWinners = playerResults.filter(p => p.hiStrength === maxHi).map(p => p.player)
                        
                        const validLow = playerResults.filter(p => p.loStrength !== null)
                        let loWinners = []
                        
                        if (validLow.length > 0) {
                            const minLo = Math.min(...validLow.map(p => p.loStrength))
                            loWinners = validLow.filter(p => p.loStrength === minLo).map(p => p.player)
                        }
                        
                        // è¨ˆç®—åº•æ± åˆ†é…
                        if (loWinners.length === 0) {
                            // æ²’æœ‰ä½ç‰Œï¼Œé«˜ç‰Œç²å‹è€…å¹³åˆ†æ•´å€‹åº•æ± 
                            hiWinners.forEach(player => {
                                results[`player_${player}`].hi_wins++
                                if (hiWinners.length === 1) {
                                    results[`player_${player}`].scoops++
                                } else {
                                    results[`player_${player}`].splits++
                                }
                            })
                        } else {
                            // æœ‰ä½ç‰Œçš„æƒ…æ³
                            hiWinners.forEach(player => {
                                results[`player_${player}`].hi_wins++
                                
                                if (loWinners.includes(player)) {
                                    // åŒä¸€ç©å®¶è´å¾—é«˜ç‰Œå’Œä½ç‰Œ
                                    if (hiWinners.length === 1 && loWinners.length === 1) {
                                        results[`player_${player}`].scoops++
                                    } else if (hiWinners.length === 1 && loWinners.length > 1) {
                                        results[`player_${player}`].three_quarters++
                                    } else if (hiWinners.length > 1 && loWinners.length === 1) {
                                        results[`player_${player}`].three_quarters++
                                    } else {
                                        results[`player_${player}`].splits++
                                    }
                                } else {
                                    // åªè´å¾—é«˜ç‰Œ
                                    if (hiWinners.length === 1) {
                                        results[`player_${player}`].splits++  // ç²å¾—1/2åº•æ± 
                                    } else {
                                        results[`player_${player}`].quarters++  // å¹³åˆ†1/2åº•æ± 
                                    }
                                }
                            })
                            
                            loWinners.forEach(player => {
                                results[`player_${player}`].lo_wins++
                                
                                if (!hiWinners.includes(player)) {
                                    // åªè´å¾—ä½ç‰Œ
                                    if (loWinners.length === 1) {
                                        results[`player_${player}`].splits++  // ç²å¾—1/2åº•æ± 
                                    } else {
                                        results[`player_${player}`].quarters++  // å¹³åˆ†1/2åº•æ± 
                                    }
                                }
                            })
                        }
                    }
                }

                async function calculateEquity() {
                    error.value = ''
                    results.value = null
                    
                    const hands = playerHands.value.slice(0, playerCount.value).map(hand => parseCards(hand))
                    const board = parseCards(boardCards.value)
                    
                    isCalculating.value = true
                    
                    setTimeout(() => {
                        try {
                            const calculationResults = EquityCalculator.calculateEquity(hands, board, 10000)
                            
                            results.value = {
                                simulations: 10000,
                                players: Object.keys(calculationResults).map((playerKey, index) => ({
                                    player: `ç©å®¶${index + 1}`,
                                    hand: hands[index].map(c => c.toString()).join(' '),
                                    color: playerColors[index % playerColors.length],
                                    ...calculationResults[playerKey]
                                }))
                            }
                        } catch (err) {
                            error.value = `è¨ˆç®—éŒ¯èª¤: ${err.message}`
                        } finally {
                            isCalculating.value = false
                        }
                    }, 100)
                }

                return {
                    playerCount,
                    playerHands,
                    boardCards,
                    isCalculating,
                    results,
                    error,
                    selectedCards,
                    showCardSelector,
                    selectorTarget,
                    currentPlayers,
                    canCalculate,
                    suits,
                    ranks,
                    openCardSelector,
                    closeCardSelector,
                    toggleCard,
                    isCardSelected,
                    isCardUsedByOthers,
                    isCardUsed,
                    getCardColor,
                    clearPlayerCards,
                    clearBoardCards,
                    clearAll,
                    calculateEquity
                }
            }
        }).mount('#app')
    </script>
</body>
</html>